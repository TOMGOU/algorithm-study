{"./":{"url":"./","title":"Introduction","keywords":"","body":"algorithm-study algorithm-study-notes data structure 一维数据 数组 链表 栈 队列 哈希 集合 二维数据 堆 树 图 并查集 字典树 algorithm 双指针 单调栈 单调队列 递归 搜索: BFS/DFS 排序算法 二分查找 贪心算法 动态规划 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-08-09 22:11:47 "},"pages/gitbook/":{"url":"pages/gitbook/","title":"Gitbook","keywords":"","body":"gitbook使用步骤 Step-1: 创建github仓库 Step-2: 克隆github仓库 git clone git@github.com:TOMGOU/algorithm-study.git Step-3: 进入项目并初始化 // npm初始化 nmp init -y // gitbook初始化 gitbook init Step-4: 创建自动化发布shell脚本git.sh cd _book git init git add . git commit -m 'update' git push -f git@github.com:/.git master:gh-pages cd ../ 用户名：USERNAME = TOMGOU 仓库名：REPO = algorithm-study Step-5: 修改package.json \"scripts\": { \"gh-pages\": \"./git.sh\" }, Step-6: 本地编辑 gitbook init (新增文件夹的时候，需要初始化) gitbook serve Step-7: github发布 npm run gh-pages Step-8: gitbook plugin【添加文件：book.json，gitbook install】 { \"title\" : \"数据结构与算法笔记\", \"author\" : \"tomgou\", \"description\" : \"数据结构与算法笔记\", \"language\" : \"zh-hans\", \"plugins\": [ \"mathjax-pro\", \"github\", \"hide-element\", \"chapter-fold\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"copy-code-button\", \"back-to-top-button\", \"tbfed-pagefooter\", \"popup\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://tomgou.github.io/algorithm-study/\" }, \"hide-element\": { \"elements\": [\".gitbook-link\"] }, \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy tomgou 2022\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 页面地址：https://tomgou.github.io/algorithm-study/ 这样使用gitbook的好处 不暴露源码（只要不push主分支） 及时预览：gitbook serve 及时发布：npm run gh-pages Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-03-24 20:08:25 "},"pages/basicKnowledge/":{"url":"pages/basicKnowledge/","title":"基础知识","keywords":"","body":"细节知识点 数组的预设值 动态规划，一般会用一维数组或者二维数组储存所有的状态，初始化的时候要注意引用类型数据的问题。 一维数组 new Array(9).fill(new Set()) ❌ new Array(9).fill(0).map(() => new Set()) ✅ 二维数组 new Array(9).fill(new Array(9).fill(false)) ❌ new Array(9).fill(0).map(() => new Array(9).fill(false)) ✅ 数组简单排序 在很多情况下，我们需要对数组预先进行简单排序处理，比如三数之和需要先排序来避免重复的结果，而 arr.sort() 本身不会按数字大小排序，需要传入一个排序函数 arr.sort((a, b) => a - b) 升序 arr.sort((a, b) => b - a) 降序 Map 和 Set 的 hash 映射 在大多数情况下，为了降低判重的复杂度，就会使用 Map 和 Set 的 has 方法快速判重。 Map const map = new Map() map.set(1, 2) if (map.get(1) === 2) { console.log('existed') } if (map.has(1)) { console.log('existed') } Set const set = new Set() set.add(1) if (set.has(1)) { console.log('existed') } recursion 的子任务 recursion(x, n / 2) * recursion(x, n / 2) ❌ recursion(x * x, n / 2) ✅ for in 和 for of 的区别 for in 不仅会遍历当前对象，还包括原型链上的可枚举属性，for in 不适合遍历数组，主要应用为对象 for of 仅遍历当前对象 const hashMap = new Map() hashMap.set('a', 1).set('b', 2) for (let key of hashMap.keys()) { console.log(hashMap.get(key)) } 字符串的相关方法总结 indexOf(): 返回字符串中指定文本首次出现的索引(位置)，未出现，返回-1,可接收两个参数，第一个参数是查找的内容，第二个参数，可传可不穿，从指定位置开始，eg：a.indexOf(‘name’, 5) lastIndexOf(): 返回字符串中指定文本最后一次出现的索引，未出现，返回-1,可接收两个参数，第一个参数是查找的内容，第二个参数，可传可不穿，从开头到指定位置，eg：a.indexOf(‘name’, 5)，从开始到索引值为5的 slice(): 提取字符串的某个部分并在新字符串中返回被提取的部分，俩参数：起始索引，终止索引，不改变原来的字符串，参数可以是负数，负数从后面开始截取字符串，如果只传一个参数，就是从该参数的索引到最后的全部字符 substring(): 与slice（）的方法一样，也不改变原数组，但是没有办法接受负数 substr(): 两个参数：起始位置，切割长度，第二个参数代表的是长度，不能为负数 toLowerCase(): 转小写 toUpperCase(): 转大写 trim(): 返回删除字符串两端的空白的结果，不改变原字符串 concat(): 字符串拼接 charAt(): 返回指定下标的字符 split(): 将字符串分割成数组 includes(): 判断是否包含某个子字符串，返回布尔值 startsWith(): 判断是否以某个子字符串开头，返回布尔值 endsWith(): 判断是否以某个子字符串结尾，返回布尔值 search(reg): 正则匹配，总是返回第一个匹配项的下标，匹配不到返回 -1 replace(reg, str): 正则替换，返回替换的结果，不改变原字符串 match(reg): 比较复杂，分三种情况：('123hello1234world12'.match(/\\d+/g)) 无全局表示符，无子集：匹配到，返回数组，匹配不到，返回 null ['1234', index: 8, input: '123hello1234world12', groups: undefined] 无全局表示符，有子集：匹配到，返回数组（第二项是子集），匹配不到，返回 null ['123', '1234', '12'] 无全局表示符：匹配到，返回数组（全为匹配到的项），匹配不到，返回 null ['123', index: 0, input: '123hello1234world12', groups: undefined] 正则基础知识： \\d: 数字 \\w: 数字字母下划线 \\s: 空格 [a-zA-Z]: 字母 [-]: 正则元素，例如：/[0-9]/g {,}: 正则量词，例如：/\\d{0,3}/g *: 0个或者多个，{0,} +: 1个或者多个，{1,} ?: 0个或者1个，{0,1} [^0]\\d*[@]$: ^ 表示以什么开头，$ 表示以什么结尾 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-29 18:31:13 "},"pages/basicKnowledge/forLoop/":{"url":"pages/basicKnowledge/forLoop/","title":"for循环","keywords":"","body":"For Loop break && continue break 终止整个 for 循环，不用等到终止条件 continue 跳过单次循环 for of && for in Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-05-05 14:51:44 "},"pages/basicKnowledge/arrMethods/":{"url":"pages/basicKnowledge/arrMethods/","title":"数组方法","keywords":"","body":"Array Methods 数组的基础方法 push: 向数组末尾添加一个或多个元素，并返回新数组的长度 pop: 删除数组的最后一个元素，并返回该元素 unshift: 向数组开头添加一个或多个元素，并返回新数组的长度 shift: 删除数组的第一个元素，并返回该元素 slice: 返回一个数组的切片副本，不改变原数组 splice(start, count, ...newElements): 删除数组中的一段，并用一个或多个值替换它们 start: 要删除元素的开始位置，这个元素也要被删除 count: 删除元素的个数 newElements: 用于替换删除元素的新元素，可以试一个或者多个 这个方法的返回值是删除的元素组成的数组，原数组会被改变。 const arr = [1, 2, 3, 4, 5] const deleteElements = arr.splice(5, 0, 6) console.log({deleteElements, arr}) // deleteElements: [] // arr: [1, 2, 3, 4, 5, 6] 数组方法的时间复杂度 数组方法 时间复杂度 pop O(1) push O(1) slice O(1) shift O(n) unshift O(n) map O(n) splice O(n) find O(n) concat O(n) sort O(nlogn) splice && slice splice 直接操作原数组, 返回切掉的数组，时间复杂度：O(n) slice 不改变原数组，返回切片新数组，时间复杂度：O(1) sort 原理 十大经典排序算法(动图演示) :https://www.cnblogs.com/onepixel/p/7674659.html 初级排序（O(n2)） 选择排序：每次找最小值，然后放到待排序数组的起始位置。 const selectSort = arr => { const len = arr.length let minIndex for (let i = 0; i 插入排序：从前往后逐步构建有序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 冒泡排序：嵌套循环，每次查看相连元素如果逆序，则交换位置。 高级排序（O(nlogn)） 快速排序：。 归并排序：。 堆排序：数组元素依次建立小顶堆，然后依次取堆顶元素并删除。 特殊排序（O(n+K)） 计数排序：。 桶排序：。 基数排序：。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-22 21:30:21 "},"pages/basicKnowledge/stringMethods/":{"url":"pages/basicKnowledge/stringMethods/","title":"字符串方法","keywords":"","body":"String Methods substring && substr Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-12 17:58:34 "},"pages/basicKnowledge/arrayLinkDiff/":{"url":"pages/basicKnowledge/arrayLinkDiff/","title":"数组和链表对比","keywords":"","body":"数组和链表操作时间复杂度对比 查询 数组的查询时间复杂度是：O(1)。 链表的查询时间复杂度是：O(n)，需要从头开始找。 写入 数组的写入时间复杂度是：O(n)，要移动其他元素。 链表的写入时间复杂度是：O(1)。 插入删除 数组的插入删除时间复杂度是：O(n)，查询是O(1)但写入是O(n)。 链表的插入删除时间复杂度是：O(n)，查询是O(n)但写入是O(1)。 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-08-08 11:31:43 "},"pages/dataStructure/":{"url":"pages/dataStructure/","title":"数据结构","keywords":"","body":"数据结构 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-21 11:56:31 "},"pages/dataStructure/linkedList/":{"url":"pages/dataStructure/linkedList/","title":"链表","keywords":"","body":"Linked List Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-07-07 10:53:55 "},"pages/dataStructure/stack/":{"url":"pages/dataStructure/stack/","title":"栈","keywords":"","body":"Stack 栈的特点：后入先出（LIFO） 单调栈：单调递增栈和单调递减栈 单调栈在解决前后对应的问题时，有奇效。 栈的应用场景 前后对应的问题，比如： 有效括号：碰到左括号将其入栈，碰到右括号将栈顶对应的左括号出战，如果最后栈里没有元素说明括号有效。 单调栈的应用场景 单调栈可以降低双指针问题的时间复杂度。 前后对应的比较隐晦，场景比普通栈问题复杂，一般难度都为：困难，需要重点关注开始状态，比如： 最大矩形面积：转化为单调递增栈问题，这是求单个柱子的最大面积的左边界就永远都是前一个柱子，当发现新的柱子高度比栈顶元素小的时候，就找到了右边界，从而计算出该柱子的最大面积。 精髓：[0, ...heights, 0], 第一个0解决第一个元素问题，最后一个0解决栈的清空问题。 接雨水：同样转化为单调递减栈问题，当新元素入栈之前，比较新元素与栈顶元素的大小关系，如果新元素比栈顶元素大，说明找到了可以装雨水的凹地，凹地元素为栈顶元素对应的柱子。雨水量的计算：width * height。width 为 (当前索引 i - 栈中栈顶元素下面的那个元素值 - 1)，height 为 Math.min【（当前高度 - 栈顶元素对应高度）,（栈中栈顶元素下面的那个元素对应的高度 - 栈顶元素对应高度）】。如果新元素小于等于栈顶元素，说明没有还没找到可以装雨水的凹地，直接入栈即可。 特别注意 width 的计算，一定要用栈顶元素前面的那个元素。 特别注意第一个元素，要直接入栈，因为没有栈顶元素用于比较。 特别注意找到凹地的目标元素，栈内至少有两个元素，即弹出栈顶元素后栈的长度不能为0，否者无法计算宽度。 栈里面存的是下标不是元素本身。 只要想获取栈顶元素，一定要先判空 LeeCode 题目：20、84、42 栈的 js 实现（没卵用） class Stack { constructor () { this.items = [] } push (item) { this.items.push(item) } pop () { return this.items.pop() } peek () { return this.items[this.items.length - 1] } isEmpty () { return this.items.length === 0 } size () { return this.items.length } toString() { return this.items.reverse().join('') } } const decToBin = num => { const stack = new Stack() while (num > 0) { stack.push(num % 2) num = Math.floor(num / 2) } return stack.toString() } console.log(decToBin(10)) Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-20 18:34:04 "},"pages/dataStructure/queue/":{"url":"pages/dataStructure/queue/","title":"队列","keywords":"","body":"Queue 栈的特点：先进先出（FIFO） 单调队列：单调递增队列和单调递减队列 解决滑动窗口的一把好手。 队列的应用场景 滑动窗口问题：窗口滑动的过程就是队列先进先出的现象。 如果只是求窗口内的元素的平均值或者总和，无需使用单调队列，正常的普通队列即可，但是如果要求队列内部元素的最值就需要单调队列出马了。 单调队列的应用场景 滑动窗口求最值，首先想到单调队列，有几个细节要注意： 队里里面存的是下标，不是元素本身 单调队列什么时候删除队头元素：index - queue[0] >= k 单调队列什么时候删除队尾元素：违反了单调性 只要想获取队头元素或者队尾，一定要先判空 LeeCode 题目：41、239 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-20 18:34:33 "},"pages/dataStructure/heap/":{"url":"pages/dataStructure/heap/","title":"堆","keywords":"","body":"Heap Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-06-29 17:10:49 "},"pages/dataStructure/hash/":{"url":"pages/dataStructure/hash/","title":"哈希","keywords":"","body":"Hash hash 表的理解 哈希表是一种根据关键码去寻找值的数据映射结构，所以关键码要唯一，否则会出现 hash 碰撞。 js 可以用来表示的 hash 表的数据结构：json、Set Set 方法 const hashMap = new Map() // 设置 hashMap.set(a, b) // 查询 hashMap.get(a) // 遍历：hashMap.keys() for (let key of hashMap.keys()) { if (hashMap.get(key) !== 0) return false } hash 表的应用场景 优势：hash 表的查询时间复杂度是 O(n)，可以用来优化两次 for 循环 应用场景：有映射关系，比如： 两数之和为9：首先把所有值都存到 hash 表中，然后查询 hashMap.get(9 - a) 是否为 undefined 字母异位词：字母相同，第一个单词用来设置 hash 表并且计数加一，第二个单词用来处理计数减一，最后验证 hash 表所有值都为 0。 LeeCode 题目：1、242 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-12-29 11:18:37 "},"pages/dataStructure/binaryTree/":{"url":"pages/dataStructure/binaryTree/","title":"二叉树","keywords":"","body":"二叉树 前序遍历：根 → 左 → 右 中序遍历：左 → 根 → 右 后序遍历：左 → 右 → 根 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-05-06 16:12:41 "},"pages/algorithm/":{"url":"pages/algorithm/","title":"算法","keywords":"","body":"算法 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-06-29 16:34:02 "},"pages/algorithm/doubleIndex/":{"url":"pages/algorithm/doubleIndex/","title":"双指针","keywords":"","body":"双指针 双指针的理解 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到降低三次 for 循环时间复杂度的目的，有的时候结合排序有奇效。 双指针的应用场景 优势：结合排序减少不必要的重复计算，降低时间复杂度。 应用场景：寻找两端边界，比如： 三数之和为0：首先排序，遍历数组，当前元素作为三数中的第一个数，另外两个数通过由两边向中间移动的双指针寻找。细节注意：为了避免重复，指针每一次移动之前都判断一下是否当前元素与下一个元素相等，相等就跳过。 最大矩形面积：由中间向两边移动的双指针可以计算当前矩形的最大面积：左边界和右边界条件都是：小于当前矩形高度。（可惜超时） LeeCode 题目：15、84 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-19 18:07:52 "},"pages/algorithm/sort/":{"url":"pages/algorithm/sort/","title":"排序","keywords":"","body":"Sort 归并排序 const merge = (left, right) => { const res = [] while (left.length && right.length) { if (left[0] { const len = arr.length if (len Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-08-08 11:43:24 "},"pages/algorithm/recursion/":{"url":"pages/algorithm/recursion/","title":"递归","keywords":"","body":"Recursion 递归细节 Pow(x, n): 通过二分来简化递归，核心思路：3^4 = (3 * 3)^2 => recursion(x * x, n / 2)，这是一种很特殊的带返回值的递归，不太符合一般的递归模板，逻辑的处理都在参数上面。 N 皇后的回溯问题：不同层级的状态，能当做参数传递的就以参数的形式进行传递。 arr 不通过参数传递，所以状态要还原：arr[x][y] = '.' var solveNQueens = function(n) { const res = [] const arr = new Array(n).fill(0).map(() => new Array(n).fill('.')) const recursion = (y, X, P, N) => { if (y === n) { res.push(arr.map(item => item.join(''))) return } for (let x = 0; x 所有状态通过参数传递，走不通的时候会自动跳回上一层，状态也就自动还原了。 var solveNQueens = function(n) { const res = [] const arr = new Array(n).fill(0).map(() => new Array(n).fill('.')) const recursion = (y, X, P, N, arr) => { if (y === n) { res.push(arr.map(item => item.join(''))) return } for (let x = 0; x item.map((value, ay) => ax === x && ay === y ? 'Q' : value))) } } } recursion(0, [], [], [], arr) return res }; 递归模板 const recursion = (level, param1, param2, ...) => { // recursion terminator 递归终结条件 if (level > max_level) { process_result return } // process logic in current level 处理当前逻辑 process(level, data, ...) // drill down 下探到下一层 recursion(level + 1, p1, ...) // reverse current level status if needed 清理当前层状态 } 分治模板 const divide_conquer = (problem, params) => { // recursion terminator 递归终结条件 if (problem == null) { process_result return } // process current problem 处理当前子问题 subproblems = split_problem(problem, data) subresult1 = divide_conquer(subproblem[0], p1) subresult2 = divide_conquer(subproblem[1], p1) subresult3 = divide_conquer(subproblem[2], p1) ... // merge 合并子问题 result = process_result(subresult1, subresult2, subresult3) // revert the current level status 清理当前层状态 } 回溯模板 const recursion = (level, param1, param2, ...) => { // recursion terminator 递归终结条件 if (level > max_level) { process_result return } // process logic in current level 处理当前逻辑 process(level, data, ...) // drill down 下探到下一层 recursion(level + 1, p1, ...) // reverse current level status if needed 清理当前层状态: 【可以直接将变量改为参数传递自动清理状态】 } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-21 11:59:58 "},"pages/algorithm/search/":{"url":"pages/algorithm/search/","title":"搜索","keywords":"","body":"Search DFS(深度优先查找) 递归 const visited = new Set() const dfs = (node) => { if (visited.has(node)) return visited.add(node) dfs(node.left) dfs(node.right) } 例子 const dfs = (root) => { let index = 0 const res = [] const recursion = (root, index) => { if (!root) return if (!res[index]) res[index] = [] res[index].push(root.val) recursion(root.left, index + 1) recursion(root.right, index + 1) } recursion(root, index) return res }; 非递归 例子 const dfs = (root) => { }; BFS(广度优先查找) const bfs = (root) => { let result = [], queue = [root] while (queue.length > 0) { let level = [], n = queue.length for (let i = 0; i 例子 var bfs = (root) => { if (!root) return [] const queue = [root], res = [] while (queue.length) { const len = queue.length const tem = [] for (let i = 0; i Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-05-09 11:11:57 "},"pages/algorithm/dynamicProgramming/":{"url":"pages/algorithm/dynamicProgramming/","title":"动态规划","keywords":"","body":"Dynamic Programming steps: 1.define subproblem 2.guess (part of solution) 3.relate subproblem solutions 4.build DP table bottom-up 解题步骤 1.define subproblem 2.build DP table bottom-up 3.DP 方程 Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-07-21 11:57:58 "},"pages/algorithm/binarySearch/":{"url":"pages/algorithm/binarySearch/","title":"二分查找","keywords":"","body":"Binary Search 二分查找的前提条件 单调 有上下边界 模板代码 findIndex = (nums, target) => { let L = 0, R = nums.length - 1 while (L target) { R = M - 1 } else { L = M + 1 } } } Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-11 14:52:03 "},"pages/algorithm/greedy/":{"url":"pages/algorithm/greedy/","title":"贪心算法","keywords":"","body":"Greedy Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2021-06-29 16:39:15 "},"pages/algorithm/bitOperation/":{"url":"pages/algorithm/bitOperation/","title":"位运算","keywords":"","body":"bit operation 位运算基础 console.log((10).toString(2)) // 1010 console.log((8).toString(2)) // 1000 // 与 &， 两个位都是 1 时，结果才为 1，否则为 0 console.log((10 & 8).toString(2)) // 1000 // 或 |，两个位都是 0 时，结果才为 0，否则为 1 console.log((10 | 8).toString(2)) // 1010 // 异或 ^， 两个位相同则为 0，不同则为 1 console.log((10 ^ 8).toString(2)) // 0010 // 非 ~，取反运算，0 则变为 1，1 则变为 0 console.log((~10 + 1).toString(2)) // -1010 console.log((~8 + 1).toString(2)) // -1000 // 左移 > 10 >> 1 判断奇偶 // 奇数 n & 1 === 1 // 偶数 n & 1 === 0 Math.floor(n / 2) n Copyright © tomgou 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-01-14 14:17:01 "}}